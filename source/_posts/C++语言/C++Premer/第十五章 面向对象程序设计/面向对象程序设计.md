---
title: 面向对象程序设计
date: 2018-07-13 12:07:12
tags: 面向对象程序设计
categories: C++
toc: true
---

主要有虚函数、访问控制等内容

<!--more-->

## 虚函数

静态类型和动态类型

1. 通过使用数据抽象，可以将类的接口和实现分离
2. 使用继承可以定义相似类型并对相似类型建模
3. 使用动态绑定，可以忽略相似类型的区别，而用统一的方式使用对象

当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。

1. 成员函数如果没用被声明为虚函数，解析过程发生在编译时候
2. 成员函数声明为虚函数，根据调用指针在运行的时候确定调用的版本。

派生类显示的著名他使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后面增加一个override关键字。

回避虚函数使用：在函数名前加作用域运算符。

## 访问控制与继承

1. protected用来声明希望与派生类共享、但不被共有访问的成员。
2. 派生类成员和友元只能通过派生类对象访问基类的受保护的成员。
3. protected成员对于派生类和友元来说可以访问。
4. protected对于类的用户来说不可访问。

某个类对其继承而来的成员的访问权限收到两个因素的影响：
1. 基类中该成员的访问说明符
2. 派生列表中派生访问说明符

爸爸受保护的属性，儿子的小三（友元）想通过儿子窃取，不行（友元不能传递）

爸爸受保护的属性，爸爸的小三想通过儿子获取，可以（谁的小三就能获取到谁的保护属性，小三具有破坏性）

派生类的作用域位于基类的作用域内

1. class的访问说明符、派生访问说明符默认都是private
2. struct的访问说明符、派生访问说明符默认都是public的

两个角度理解访问控制：

1. 普通用户
2. 实现者

派生类的成员隐藏同名的基类成员。

使用作用域运算符来使用一个被隐藏的基类成员

除了覆盖继承而来的虚函数，派生类最好不用重新定义其他在基类中名字

函数调用解析过程

假如我们调用p->mem()，

1. 确定p的静态类型
2. 在静态类型对应的类中找mem
3. 找到后判断是否虚函数，是产生虚函数调用版本、不是编译器产生常规调用版本。

名字查找先于类型检测


## 构造函数与拷贝控制

析构函数定义成虚函数，确保删除指针能执行正确的版本。

如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。









