---
title: 拷贝控制
date: 2018-07-13 12:07:12
tags: 拷贝控制
categories: 拷贝控制
toc: true
---

我们将学到：拷贝、赋值、移动、销毁做什么？

1. 拷贝构造函数  
2. 拷贝赋值运算符
3. 移动构造函数
4. 移动赋值运算符
5. 析构函数

函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么
运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。

如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。

<!--more-->

## 拷贝、赋值、销毁

### 拷贝构造函数

如果一个函数的第一个参数是自身类型的引用，且任何额为的参数都有默认值，则，此构造函数是拷贝构造函数。

```
class Foo
{		
   plublic:
   Foo(canst Foo&); // 拷贝构造函数
};
```

#### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。这个拷贝构造函数称为合成拷贝构造函数。合成的拷贝构造函数会将其参数逐个拷贝到正在创建的对象中。除了静态成员。

合成拷贝构造函数如何拷贝：

1. 类类型：使用其拷贝构造函数来拷贝
2. 内置类型：直接拷贝
3. 数组：逐个拷贝数组成员

例子：

```
Sales_data::Sales_data(const Sales_data& orig):
bookNO(orig.bookNO),
units_sold(orig.units_sold),
revenue(orig.revenue)
{}
```

#### 拷贝初始化

1. 直接初始化：我们实际上要求编译器用普通的函数匹配类选择与我们提供的参数最匹配的构造函数
2. 拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还进行类型转换。

拷贝初始化发生的场景：
1. 将一个对象作为实参传递给一个非引用类型的形参
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
4. insert 、push（emplace 直接初始化）

#### 参数和返回值

当一个函数具有非引用类型的返回值类型时，返回值会被用来初始化调用方的结果

### 拷贝赋值运算符
赋值运算符就是一个名为opertor =的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。
如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式this参数。
```
Foo& operator=(const Foo &);
```
赋值运算符通常应该返回一个指向其左侧运算对象的引用。
```
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
	booNO = rhs.bookNO;
	units_sold = rhs.units_sold;
	revenue = rhs.revenue;
	return *this;
}
```
### 析构函数
1. 构造函数初始化对象的非static数据成员。
2. 析构函数释放对象使用的资源，并销毁对象的非静态成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数。
```
~Foo();
```
1. 在构造函数中，成员的初始化是在函数体执行前完成的，且按照他们在类中出现的顺序进行初始化。
2. 在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。智能指针是类类型，所以具有析构函数，所以销毁的时候会销毁其指向的对象。

什么时候会调用析构函数：
1. 变量在离开其作用域时
2. 对象被销毁，其成员被销毁
3. 容器被销毁，其成员被销毁
4. 动态分配的对象，delete 运算符时会被销毁
5. 对于临时对象，当创建他的完整表达式结束时被销毁

<font color=red>析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的</font>
### 三五法则
需要析构函数的类也需要拷贝和赋值。
需要拷贝操作的类也需要赋值操作。
### 使用=default
可以通过将拷贝控制成员定义为=default来显示的要求编译器生产合成的版本。合成函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default。
### 阻止拷贝
应用场景：iostream类阻止了拷贝，以避免多个对象写入或读取相同的io缓存。
删除函数是这样一种函数：我们虽然声明了他们，单不能以任何方式使用他们。

=default 、=delete区别：
1. =delete必须在函数第一次声明的时候。=default直到编译器生产代码的时候才需要。
2. 可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数或者拷贝控制成员使用=default。

析构函数不能是删除的，如果析构函数被删除了，就无法消化此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类的临时变量。如果一个类的某个成员的类型删除了析构函数，我们不能定义该类的变量或者临时对象。因为如果一个成员的析构函数是删除的，则改成员无法被销毁，而如果一个成员无法被销毁，则对象整体也就无法被销毁了。

对于删除了析构函数的类型，虽然不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象。但是不能释放这些对象。

合成的拷贝成员可能是删除的：如果一个类有数据成员不能默认构造、拷贝、赋值、销毁。则对应的成员函数将被定义为删除的。

一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。原因是：如果没有这条规则，我们可能创建出无法销毁的对象。

对于据用引用成员或者无法默认构造的const成员的类。编译器不会为其合成默认构造函数。如果一个类有const成员，则他不能使用合成的拷贝赋值运算符，毕竟，次运算符视图赋值所有成员，而将一个新值赋予一个const对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。
## 拷贝控制和资源管理
管理类外资源的类必须定义拷贝控制函数。
1. 类值拷贝
2. 类指针拷贝

赋值运算符通常组合了析构函数和构造函数的操作。类型析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。

```
HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
	auto newp = new string(*rhs.ps); //拷贝底层String
	delete ps; //是否旧内存
	ps = newp;
	i=rhs.i;
	return *this; //返回本对象
}
```

对于一个赋值运算符来说，正确工作非常重要的，即使将一个对象赋予它吱声，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。

引用计数的工作方式：
* 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。
* 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝析构函数递增共享的计数器。指出给定对象的状态又被一个新用户共享。
* 析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
* 拷贝赋值运算符递增右侧运算对象的计算器。递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。











