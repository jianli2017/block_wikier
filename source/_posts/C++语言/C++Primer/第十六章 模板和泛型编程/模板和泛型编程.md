---
title: 模板和泛型编程
date: 2018-07-25 12:07:12
tags: 模板和泛型编程
categories: C++
toc: true
---

1. 定义模板
2. 模板实参推断
3. 重载与模板
4. 可变参数模板
5. 模板的特例化

面向对象编程和泛型编程都能处理程序在不知道类型的情况，不同之处在于： OOP能处理类型在运行之前未知的情况，而在泛型编程中，在编译器时就能获知类型了。
<!--more-->

一个模板就是一个创建类或函数的蓝图或者公式。当我们提足够的信息，将蓝图转化为特定的类或函数。这种转化发生在编译期。

## 定义模板

### 函数模板

```
template <typename T>
int compare(const T &v1, const T &v2);
```

模板定义以template开始，后跟一个模板参数列表。

函数参数： 调用时，实参初始化形参。

模板参数表示类、函数定义中用到的类型或值。使用模板时，指定模板实参，绑定到模板形参上。

函数实参推断模板实参。

* 模板类型参数 ： 
* 非类型参数：是常量，必须能字编译时处理。使用场景：数组的大小
* 模板编译：当编译器遇到一个模板时，他并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用模板时，编译器才生成代码。 函数模板和类模板成员函数的定义放在头文件中

### 类模板

* 类模板实例化：必须提供模板实参，由于没法推断出来。 一个类模板的每个实例都形成一个独立的类。类型Blob<String> 与任何其他Blob类型都没有关联。
* 类模板作用域中引用模板类型：
* 定义在类模板之外的成员函数必须以关键字 template开始。 （由于每个实例都以自己版本的成员函数）

template <typename T>
ret-type Blob<T>::memberName(param)

* 构造函数的定义以模板参数开始
* 类模板成员函数实例化：一个类模板的成员函数只有当程序用到它时才进行实例化。如果一个函数没有调用，则它不会实例化。
* 在类内部代码简化模板类名的使用。当我们使用类模板类型时必须提供实参，但这一规则有一个例外。在类模板的作用域中，可以指向使用模板名，不提供实参
* 在类模板外使用类模板名：在类模板外定义其成员时，必须记住，我们并不在类的作用域中。知道遇到类名，才表示进入作用域。返回值在类的作用域外。
