---
title: 4.3 最小生成树
date: 2019-07-23 12:07:12
tags: 
categories: 算法4
toc: true
---


图的生成树是它的一棵含有所有顶点的无环连通子图，一幅加权无向图的最小生成树(MST)是它的一棵权值(树中所有边的权值之后)最小的生成树

最小生成树的解决方法有： prim算法、kruskal算法


<!--more-->

## 原理

树的性质：

1. 用一条边连接树中的任意两个顶点都会产生一个新的环
2. 从树中删去一条边会得到两棵独立的树

切分定理： 图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合，横切边是一条连接两个属于不同集合的顶点的边

命题j： 在一幅加权图中，给定任意的切分，它的横切边中权重最小者必然属于图的最小生成树

证明： 令e为权重最小的横切边，T为图的最小生成树，我们采用反证法：假设T不包含e，那么如果将e假如T，得到的图必要包含一条经过e的环，且这个环至少包含另一条横切边，设为f ，f的权重必然大于e，那么我们删除调f，而保留e就可以得到一颗权重更小的生成树。和我们的假设矛盾。


![最小生成树的性质](4.3 最小生成树/mst_propery.png)

![最小生成树的切分原理](4.3 最小生成树/mst_cut.png)

命题K(最小生成树的贪心算法) 下面这种方法会将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下，所有边均为灰色，找到一种切分，它产生的横切边均不为黑色，将它的权重最小的横切边标记为黑色，反复，知道标记了V-1条黑色的边为止。

![小生成树的贪心算法的过程展示](4.3 最小生成树/mst_cut_process.png)

## 加权无向图的数据类型

边的代码实现如下：

```
enum EdgeError: Error {
    case invalidEdge(egdg: Int)
}
class Edge :Comparable {
    let _v: Int
    let _w: Int
    let _weight: Double
    
    init(v: Int, w: Int, weight: Double) {
        self._v = v
        self._w = w
        self._weight = weight
    }
    
    func weight() -> Double {  //返回权重
        return self._weight
    }
    
    func either() -> Int { //返回任意一个顶点
        return self._v
    }
    
    func other(_ v: Int) throws -> Int { //返回另一个顶点
        if self._v == v {
            return self._w
        } else if (self._w == v) {
            return self._v
        } else {
            print("取顶点错误")
            throw EdgeError.invalidEdge(egdg: v)
        }
    }
    
    static func < (lhs: Edge, rhs: Edge) -> Bool {
        if lhs._weight < rhs._weight {
            return true
        }
        return false
    }
    
    static func == (lhs: Edge, rhs: Edge) -> Bool {
        if  lhs._weight == rhs._weight {
            return true
        }
        return false
    }
    
    func toString() -> String {
        return String.init(format: "%d,%d,%.2f", self._v, self._w, self._weight)
    }
}
```

加权图的实现如下：

```
class EdgeWeightedGraph {
    var _vertex: Int  //顶点的个数
    var _edges: Int //边的个数
    var _adj: [[Edge]] //邻接表
    init(vertex: Int) {
        self._vertex = vertex
        self._edges = 0
        self._adj = [[Edge]](repeating: [Edge](), count: vertex)
    }
    
    convenience init?(inStream: ReadFile) {
        let v = inStream.readInt()
        if v != nil {
            self.init(vertex: v!)
        } else {
            return nil
        }
        let edge = inStream.readInt()
        if edge != nil {
            for _ in 0..<edge! {
                let v = inStream.readInt()
                let w = inStream.readInt()
                let weight = inStream.readDouble()
                if v != nil && w != nil && weight != nil {
                    let edge = Edge(v: v!, w: w!, weight: weight!)
                    self.addEdge(edge)
                } else {
                    return nil
                }
            }
        } else {
            return nil
        }
    }
    
    func v() -> Int { //返回顶点数
        return self._vertex
    }
    
    func e() -> Int {  //返回边数
        return self._edges
    }
    func addEdge(_ edge: Edge) {
        let v = edge.either()
        let w = try! edge.other(v)
        self._adj[v].insert(edge, at: 0)
        self._adj[w].insert(edge, at: 0)
        self._edges += 1
    }
    
    func adj(_ v: Int) -> [Edge] {
        return self._adj[v]
    }
    
    func edges() -> [Edge] { //枚举所有的边
        var result = [Edge]()
        for v in 0..<self._vertex {
            for e in self.adj(v) {
                if try! e.other(v) > v {
                    result.insert(e, at: 0)
                }
            }
        }
        return result
    }
    
    func toString() -> String {
        var result: String  =
        """
        \(self.v()) vertixes \(self.e()) edges \n
        """
        for i in 0..<self.v() {
            result += "\(i) :"
            for w in self.adj(i) {
                result += "\(w.toString())   "
            }
            result +=
            """
            \n
            """
        }
        return result
    }
    
    static func test() {
        let path = TinyEWG
        let file = ReadFile(fileName: path)
        guard  file != nil else {
            print("建立文件失败！！！")
            return
        }
        
        let edgeGraph = EdgeWeightedGraph(inStream: file!)
        guard edgeGraph != nil else {
            print("建立图失败")
            return
        }
        
        let result = edgeGraph!.toString()
        print(result)
    }
}
```
## 最小生成树的API 和测试用例

最小生成树的表示方法：

1. 一组边的列表
2. 一幅加权无向图
3. 一个以顶点为索引且包含父节点链接的数组

## Prim 算法

思路： 一开始，这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中顶点与不在树中的顶点，且权重最小的边假如树中（即由树中顶点所定义的切分中的一条横切边）。

每当我们向树中添加一条边之后，也向树中添加一个顶点。 就要将连接这个顶点和其他所有不在树中的顶点加入到优先队列中，用marked[]来标识， 但是还有一点，连接新加入树中的顶点，与其他已经在树中的顶点的所有边都失效了。

![prim算法的轨迹](4.3 最小生成树/prim_trace.png)



## Prim算法的即时实现


![prim算法的即时轨迹](4.3 最小生成树/Prim_trace_eager.png)


## Kruskal


![Kruskal算法的轨迹](4.3 最小生成树/Kruskal.png)

## 参考


1. [算法4 官网地址](https://algs4.cs.princeton.edu/code/javadoc/)

